package lesson10.labsolns.prob4b;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import lesson10.lecture.jdbc.read_trywithres.ConnectManager;
import lesson10.lecture.jdbc.transact.Customer;

public class ZipUpdate2 {
	
    private static final Logger LOG = Logger.getLogger(ZipUpdate2.class.getName()); 
    private String readZipQuery = "SELECT name, zip FROM Customer";
    private String insertQuery = "INSERT INTO CUSTOMER (name, street, city, zip) "
			+"VALUES (?, ?, ?, ?)"; 
    		
    private static List<Customer> createNewCustomers() {
    	List<Customer> list = new ArrayList<Customer>() {
    		{
    			add(new Customer("Paul", "12 Harrison Dr.", "Fairfield", "52556"));
    			add(new Customer("Jeff", "85 N W 4th Street", "Brighton", "53414"));
    			add(new Customer("Andy", "300 N. University Ave", "Palo Alto", "94301"));
    			add(new Customer("Arnold", "11 West Whitworth St.", "Danforth", "43214"));
    		}
    	};
    	return list;
    }
    public static void main(String[] args) {
    	
    	ZipUpdate2 zu = new ZipUpdate2();
    	List<Customer> newCustomers = createNewCustomers();
    	try {
    		System.out.println(zu.insertRecords(newCustomers));
    	} catch(SQLException e) {
    		System.out.println("Inserts failed:");
    		for(Throwable t : e) {
				System.out.println("* " + t.getMessage());
			}
    	}
    }
	/**
	 * Extracts from Customer table all records with first digit of zip equal to 5.
	 * Updates each of these zips to zip-1000.
	 * 
	 * Reading zips does not require a transaction, but updating the batch of
	 * records found is done within a transaction
	 */
	public String insertRecords(List<Customer> list) throws SQLException {
		String outputMessage = "The Customers on the list %s were successfully inserted." +
				" List of new customer ids: %s";
		try {
			List<NameZip> oldlist = readRecords();
			List<Customer> readyToInsert = prepareList(list, oldlist);
			List<Integer> newIds = insertPreparedRecords(readyToInsert);
			return String.format(outputMessage, readyToInsert, newIds);
		} catch(SQLException e) {
			for(Throwable t : e) {
				System.out.println("* " + t.getMessage());
			}
			return null;
		}
	}
	
	private List<Integer> insertPreparedRecords(List<Customer> records) 
			throws SQLException {
		List<Integer> generatedKeys = new ArrayList<>();
		//Step 1: Get Connection, manage using try-with-resournces
		try(Connection conn = ConnectManager.getConnection()) {
			
			try {
				//begin transaction
				conn.setAutoCommit(false);	
				
				//perform inserts
				for(Customer cust : records) {
					PreparedStatement insertStatement = prepareCustInsertQuery(cust, conn);
					int id = performInsert(insertStatement);
					generatedKeys.add(id);
				}
				
				//commit (if queries fail, this line won't execute)
				conn.commit();
			} catch(SQLException e) {
				//if an operation fails, rollback
				conn.rollback();
				//log exception
				StringBuilder sb = new StringBuilder();
				for(Throwable t : e) {
					sb.append("+ " + e.getMessage()+ "\n");
				}
				LOG.warning("SQLException thrown:\n" + sb.toString());
				throw e;
			} finally{ 
				conn.setAutoCommit(true);			
			}
		}
		return generatedKeys;
	}
	
	/**
	 * Returns a sublist of newCusts whose
	 * name and zip are different from those in the currentCusts list
	 * and for which zips beginning with '5' have been modified with +4 code
	 */
	private List<Customer> prepareList(List<Customer> newCusts, List<NameZip> currentCusts) {
		/*
		ArrayList<Customer> newList = new ArrayList<>();
		for(Customer cust : newCusts) {
			NameZip nz = new NameZip(cust.getName(), cust.getZip());
			if(!currentCusts.contains(nz)) newList.add(cust);
		}
		return null;*/
		
		return newCusts.stream()
		        .filter(cust -> !currentCusts.contains(new NameZip(cust.getName(), cust.getZip())))
		        .map(cust -> plus4Code(cust))
		        .collect(Collectors.toList());
	}
	
	/**
	 * Adjust zip of this customer by adding +4 code, if the zip begins with '5'
	 */
	private Customer plus4Code(Customer cust) {
		if(cust.getZip().charAt(0) == '5') {
			cust.setZip(cust.getZip() + "-1000");
		}
		return cust;
	}
	
	private PreparedStatement prepareCustInsertQuery(Customer cust, Connection conn) 
			throws SQLException{
		//to get the autogenerated key, we must include the extra parameter here
		PreparedStatement insertStatement 
		  = conn.prepareStatement(insertQuery, Statement.RETURN_GENERATED_KEYS);
		insertStatement.setString(1, cust.getName());
		insertStatement.setString(2, cust.getStreet());
		insertStatement.setString(3, cust.getCity());
		insertStatement.setString(4, cust.getZip());
		return insertStatement;
		
	}
	
	private int performInsert(PreparedStatement stmt) throws SQLException {
		stmt.executeUpdate();
		
		int key = -1;
		ResultSet rs = stmt.getGeneratedKeys();
		if (rs.next()) {
			key = rs.getInt(1);
			LOG.info("Generated key for auto_increment id column after insert: "
					+ key);
		} else {
			LOG.info("No generated key for " + stmt.toString());
		}
		
		return key;
	}
	
	
	private List<NameZip> readRecords() throws SQLException {
		List<NameZip> retVal = new ArrayList<>();
		try(Connection conn = ConnectManager.getConnection()) {
			Statement stat = conn.createStatement();
			//using this try/catch to (partially) handle exceptions
			//involving statements and executing queries -- such
			//exceptions are logged and then re-thrown
			try {
				ResultSet rs = stat.executeQuery(readZipQuery);				
				while(rs.next()) {
					retVal.add(new NameZip(rs.getString("name").trim(), rs.getString("zip").trim()));
				}					
			} catch(SQLException e) {
				//log exception
				StringBuilder sb = new StringBuilder();
				
				//SQLException now implements Iterable, so 
				//it is possible to iterate through chained 
				//exceptions like this
				for(Throwable t : e) {
					sb.append("+ " + t.getMessage()+ "\n");
				}
				LOG.warning("SQLException thrown:\n" + sb.toString());
				throw e;
			}
		}
		LOG.info("Records found: " + retVal);
		return retVal;	
	}
}
